# danngam 데이터 모델 설계

**작성일**: 2026-02-14
**버전**: 2.0
**프로젝트**: danngam (농기계 공유 플랫폼)
**상태**: MVP - 로컬 Mock JSON 기반 (향후 PostgreSQL로 마이그레이션)

---

## 1. 문서 정보

### 개요
이 문서는 danngam 프로젝트의 데이터 모델, 로컬 저장소 구조(Mock JSON), 그리고 향후 백엔드 DB 스키마를 정의합니다.

### 프로젝트 특성
- **현재 단계**: MVP (Minimum Viable Product)
- **저장소**: LocalStorage (Mock JSON + sqflite)
- **향후**: PostgreSQL 기반 백엔드
- **핵심 특징**: 이동형(MOBILE)과 고정형(FIXED) 농기계 구분
- **추가 기능**: 장비 등록, 실시간 채팅

### 문서 구조
1. 아키텍처 개요
2. 로컬 데이터 (Mock JSON)
3. Dart 모델 클래스
4. JSON 직렬화
5. LocalStorage 저장 구조
6. 백엔드 DB 스키마 (향후)
7. 관계도 (ER Diagram)
8. 마이그레이션 전략
9. 검증 규칙
10. 인수 기준

---

## 2. 아키텍처 개요

### 2.1 현재 아키텍처 (MVP - Local)

```
┌─────────────────────────────────────────────────┐
│             Flutter App (UI Layer)              │
└────────────────┬────────────────────────────────┘
                 │
┌─────────────────▼────────────────────────────────┐
│         Provider / BLoC (State Management)       │
└────────────────┬────────────────────────────────┘
                 │
┌─────────────────▼────────────────────────────────┐
│      Repository (Mock Service)                   │
│  ├─ EquipmentRepository                          │
│  ├─ BookingRepository                            │
│  ├─ UserRepository                               │
│  ├─ ChatRepository                               │
│  └─ MessageRepository                            │
└────────────────┬────────────────────────────────┘
                 │
┌─────────────────▼────────────────────────────────┐
│    Local Storage (Mock JSON + sqflite)           │
│  ├─ assets/data/users.json                       │
│  ├─ assets/data/equipments.json                  │
│  ├─ assets/data/bookings.json                    │
│  ├─ assets/data/chats.json                       │
│  └─ assets/data/messages.json                    │
└─────────────────────────────────────────────────┘
```

### 2.2 향후 아키텍처 (Backend - PostgreSQL)

```
┌─────────────────────────────────────────────────┐
│             Flutter App (UI Layer)              │
└────────────────┬────────────────────────────────┘
                 │
┌─────────────────▼────────────────────────────────┐
│         Provider / BLoC (State Management)       │
└────────────────┬────────────────────────────────┘
                 │
┌─────────────────▼────────────────────────────────┐
│           HTTP Client (API Communication)        │
└────────────────┬────────────────────────────────┘
                 │
         (Network Communication)
                 │
┌─────────────────▼────────────────────────────────┐
│        FastAPI / Node.js Backend                 │
│  ├─ Equipment API                                │
│  ├─ Booking API                                  │
│  ├─ User API                                     │
│  ├─ Chat API (WebSocket)                         │
│  └─ Message API (WebSocket)                      │
└────────────────┬────────────────────────────────┘
                 │
┌─────────────────▼────────────────────────────────┐
│         PostgreSQL Database                      │
│  ├─ users                                        │
│  ├─ equipment                                    │
│  ├─ bookings                                     │
│  ├─ chats                                        │
│  ├─ messages                                     │
│  ├─ reviews                                      │
│  ├─ payments                                     │
│  └─ equipment_images                             │
└─────────────────────────────────────────────────┘
```

---

## 3. 로컬 데이터 구조 (Mock JSON)

로컬 개발 단계에서 사용할 Mock JSON 파일들의 구조를 정의합니다.

### 3.1 users.json (사용자)

위치: `assets/data/users.json`

```json
{
  "users": [
    {
      "id": "user-001",
      "name": "김철수 (공급자)",
      "phone": "01012345678",
      "email": "supplier@example.com",
      "profileImage": "https://example.com/profiles/user-001.jpg",
      "location": {
        "latitude": 37.4979,
        "longitude": 127.0276,
        "address": "경기도 성남시 분당구",
        "city": "경기도",
        "country": "대한민국"
      },
      "rating": 4.8,
      "reviewCount": 32,
      "role": "SUPPLIER",
      "createdAt": "2025-06-15T10:30:00.000Z",
      "updatedAt": "2026-02-14T15:20:00.000Z"
    },
    {
      "id": "user-002",
      "name": "이영희 (수요자)",
      "phone": "01087654321",
      "email": "renter@example.com",
      "profileImage": null,
      "location": {
        "latitude": 37.5665,
        "longitude": 126.9780,
        "address": "서울시 강남구",
        "city": "서울시",
        "country": "대한민국"
      },
      "rating": 4.2,
      "reviewCount": 8,
      "role": "RENTER",
      "createdAt": "2025-11-20T08:45:00.000Z",
      "updatedAt": "2026-02-14T09:10:00.000Z"
    }
  ]
}
```

### 3.2 equipments.json (장비)

위치: `assets/data/equipments.json`

```json
{
  "equipments": [
    {
      "id": "eq-001",
      "name": "100마력 트랙터",
      "category": "트랙터",
      "type": "MOBILE",
      "description": "신형 현대 100마력 트랙터. 잘 관리되었으며 즉시 사용 가능합니다.",
      "images": [
        "https://example.com/equipments/eq-001-1.jpg",
        "https://example.com/equipments/eq-001-2.jpg"
      ],
      "pricePerHour": 50000,
      "location": {
        "latitude": 37.4979,
        "longitude": 127.0276,
        "address": "경기도 성남시 분당구 판교로 123",
        "city": "경기도",
        "country": "대한민국"
      },
      "status": "AVAILABLE",
      "averageRating": 4.8,
      "reviewCount": 15,
      "supplierId": "user-001",
      "createdAt": "2025-07-10T14:20:00.000Z",
      "updatedAt": "2026-02-14T10:00:00.000Z"
    },
    {
      "id": "eq-002",
      "name": "콤바인 수확기",
      "category": "콤바인",
      "type": "MOBILE",
      "description": "2년식 콤바인. 추수 시즌에 최적화되었습니다.",
      "images": [
        "https://example.com/equipments/eq-002-1.jpg"
      ],
      "pricePerHour": 80000,
      "location": {
        "latitude": 37.4979,
        "longitude": 127.0276,
        "address": "경기도 성남시 분당구 판교로 123",
        "city": "경기도",
        "country": "대한민국"
      },
      "status": "RENTED",
      "averageRating": 4.5,
      "reviewCount": 8,
      "supplierId": "user-001",
      "createdAt": "2025-08-05T09:15:00.000Z",
      "updatedAt": "2026-02-13T16:30:00.000Z"
    },
    {
      "id": "eq-003",
      "name": "곡물 건조기",
      "category": "건조기",
      "type": "FIXED",
      "description": "30톤 용량 곡물 건조기. 온도 조절 완벽하고 효율적입니다.",
      "images": [
        "https://example.com/equipments/eq-003-1.jpg",
        "https://example.com/equipments/eq-003-2.jpg"
      ],
      "pricePerHour": 35000,
      "location": {
        "latitude": 37.4979,
        "longitude": 127.0276,
        "address": "경기도 성남시 분당구 판교로 123",
        "city": "경기도",
        "country": "대한민국"
      },
      "status": "AVAILABLE",
      "averageRating": 4.9,
      "reviewCount": 22,
      "supplierId": "user-001",
      "createdAt": "2025-05-12T11:40:00.000Z",
      "updatedAt": "2026-02-14T12:00:00.000Z"
    }
  ]
}
```

### 3.3 bookings.json (예약)

위치: `assets/data/bookings.json`

```json
{
  "bookings": [
    {
      "id": "booking-001",
      "equipmentId": "eq-001",
      "renterId": "user-002",
      "supplierId": "user-001",
      "startTime": "2026-02-15T09:00:00.000Z",
      "endTime": "2026-02-15T17:00:00.000Z",
      "status": "PENDING",
      "totalAmount": 400000,
      "platformFee": 32000,
      "paymentId": "pay-001",
      "createdAt": "2026-02-14T10:30:00.000Z",
      "updatedAt": "2026-02-14T10:30:00.000Z"
    },
    {
      "id": "booking-002",
      "equipmentId": "eq-002",
      "renterId": "user-002",
      "supplierId": "user-001",
      "startTime": "2026-02-10T08:00:00.000Z",
      "endTime": "2026-02-10T16:00:00.000Z",
      "status": "COMPLETED",
      "totalAmount": 640000,
      "platformFee": 51200,
      "paymentId": "pay-002",
      "createdAt": "2026-02-08T14:15:00.000Z",
      "updatedAt": "2026-02-10T17:00:00.000Z"
    }
  ]
}
```

### 3.4 chats.json (채팅)

위치: `assets/data/chats.json`

```json
{
  "chats": [
    {
      "id": "chat-001",
      "senderId": "user-001",
      "receiverId": "user-002",
      "lastMessage": "네, 예약 받겠습니다.",
      "lastMessageTime": "2026-02-14T15:45:00.000Z",
      "unreadCount": 0,
      "createdAt": "2026-02-14T10:00:00.000Z",
      "updatedAt": "2026-02-14T15:45:00.000Z"
    },
    {
      "id": "chat-002",
      "senderId": "user-002",
      "receiverId": "user-001",
      "lastMessage": "장비는 언제 수령 가능한가요?",
      "lastMessageTime": "2026-02-14T14:20:00.000Z",
      "unreadCount": 1,
      "createdAt": "2026-02-13T16:30:00.000Z",
      "updatedAt": "2026-02-14T14:20:00.000Z"
    }
  ]
}
```

### 3.5 messages.json (메시지)

위치: `assets/data/messages.json`

```json
{
  "messages": [
    {
      "id": "msg-001",
      "chatId": "chat-001",
      "senderId": "user-001",
      "content": "안녕하세요. 트랙터 렌트에 관심이 있으신가요?",
      "imageUrl": null,
      "isRead": true,
      "createdAt": "2026-02-14T10:05:00.000Z"
    },
    {
      "id": "msg-002",
      "chatId": "chat-001",
      "senderId": "user-002",
      "content": "네, 내일 필요합니다. 가능한가요?",
      "imageUrl": null,
      "isRead": true,
      "createdAt": "2026-02-14T10:10:00.000Z"
    },
    {
      "id": "msg-003",
      "chatId": "chat-001",
      "senderId": "user-001",
      "content": "네, 예약 받겠습니다.",
      "imageUrl": null,
      "isRead": true,
      "createdAt": "2026-02-14T10:15:00.000Z"
    },
    {
      "id": "msg-004",
      "chatId": "chat-002",
      "senderId": "user-002",
      "content": "장비는 언제 수령 가능한가요?",
      "imageUrl": null,
      "isRead": false,
      "createdAt": "2026-02-14T14:20:00.000Z"
    }
  ]
}
```

---

## 4. Dart 모델 클래스

### 4.1 Location 모델

```dart
// lib/features/shared/models/location_model.dart

import 'dart:math' as math;

class Location {
  final double latitude;
  final double longitude;
  final String address;
  final String city;
  final String country;

  Location({
    required this.latitude,
    required this.longitude,
    required this.address,
    required this.city,
    required this.country,
  });

  Map<String, dynamic> toJson() => {
    'latitude': latitude,
    'longitude': longitude,
    'address': address,
    'city': city,
    'country': country,
  };

  factory Location.fromJson(Map<String, dynamic> json) => Location(
    latitude: (json['latitude'] as num).toDouble(),
    longitude: (json['longitude'] as num).toDouble(),
    address: json['address'] as String,
    city: json['city'] as String,
    country: json['country'] as String,
  );

  // 두 위치 간 거리 계산 (단위: km)
  double distanceTo(Location other) {
    const earthRadiusKm = 6371.0;
    final dLat = _degreesToRadians(other.latitude - latitude);
    final dLon = _degreesToRadians(other.longitude - longitude);

    final a = math.sin(dLat / 2) * math.sin(dLat / 2) +
        math.cos(_degreesToRadians(latitude)) *
            math.cos(_degreesToRadians(other.latitude)) *
            math.sin(dLon / 2) *
            math.sin(dLon / 2);

    final c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a));
    return earthRadiusKm * c;
  }

  static double _degreesToRadians(double degrees) {
    return degrees * math.pi / 180;
  }
}
```

### 4.2 User 모델

```dart
// lib/features/auth/data/models/user_model.dart

enum UserRole { supplier, renter }
enum TrustLevel { low, medium, high }

class UserEntity {
  final String id;
  final String name;
  final String phone;
  final String email;
  final String? profileImage;
  final Location location;
  final double rating;
  final int reviewCount;
  final UserRole role;
  final DateTime createdAt;
  final DateTime updatedAt;

  UserEntity({
    required this.id,
    required this.name,
    required this.phone,
    required this.email,
    required this.profileImage,
    required this.location,
    required this.rating,
    required this.reviewCount,
    required this.role,
    required this.createdAt,
    required this.updatedAt,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'phone': phone,
    'email': email,
    'profileImage': profileImage,
    'location': location.toJson(),
    'rating': rating,
    'reviewCount': reviewCount,
    'role': role.toString().split('.').last,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
  };

  factory UserEntity.fromJson(Map<String, dynamic> json) => UserEntity(
    id: json['id'] as String,
    name: json['name'] as String,
    phone: json['phone'] as String,
    email: json['email'] as String,
    profileImage: json['profileImage'] as String?,
    location: Location.fromJson(json['location'] as Map<String, dynamic>),
    rating: (json['rating'] as num).toDouble(),
    reviewCount: json['reviewCount'] as int,
    role: UserRole.values.firstWhere(
      (e) => e.toString().split('.').last == json['role'],
    ),
    createdAt: DateTime.parse(json['createdAt'] as String),
    updatedAt: DateTime.parse(json['updatedAt'] as String),
  );
}

class UserModel extends UserEntity {
  UserModel({
    required String id,
    required String name,
    required String phone,
    required String email,
    String? profileImage,
    required Location location,
    required double rating,
    required int reviewCount,
    required UserRole role,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : super(
    id: id,
    name: name,
    phone: phone,
    email: email,
    profileImage: profileImage,
    location: location,
    rating: rating,
    reviewCount: reviewCount,
    role: role,
    createdAt: createdAt,
    updatedAt: updatedAt,
  );

  bool isNewUser() {
    return DateTime.now().difference(createdAt).inDays < 7;
  }

  String getRatingDisplay() {
    if (rating == 0) return '평점 없음';
    return '$rating ★ ($reviewCount)';
  }

  TrustLevel getTrustLevel() {
    if (reviewCount < 5) return TrustLevel.low;
    if (rating < 4.0) return TrustLevel.medium;
    return TrustLevel.high;
  }
}
```

### 4.3 Equipment 모델

```dart
// lib/features/equipment/data/models/equipment_model.dart

enum EquipmentType { mobile, fixed }
enum EquipmentStatus { available, rented, maintenance }
enum PriceCategory { cheap, moderate, expensive, premium }

class EquipmentEntity {
  final String id;
  final String name;
  final String category;
  final EquipmentType type;
  final String description;
  final List<String> images;
  final double pricePerHour;
  final Location location;
  final EquipmentStatus status;
  final double averageRating;
  final int reviewCount;
  final String supplierId;
  final DateTime createdAt;
  final DateTime updatedAt;

  EquipmentEntity({
    required this.id,
    required this.name,
    required this.category,
    required this.type,
    required this.description,
    required this.images,
    required this.pricePerHour,
    required this.location,
    required this.status,
    required this.averageRating,
    required this.reviewCount,
    required this.supplierId,
    required this.createdAt,
    required this.updatedAt,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'category': category,
    'type': type.toString().split('.').last,
    'description': description,
    'images': images,
    'pricePerHour': pricePerHour,
    'location': location.toJson(),
    'status': status.toString().split('.').last,
    'averageRating': averageRating,
    'reviewCount': reviewCount,
    'supplierId': supplierId,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
  };

  factory EquipmentEntity.fromJson(Map<String, dynamic> json) =>
      EquipmentEntity(
    id: json['id'] as String,
    name: json['name'] as String,
    category: json['category'] as String,
    type: EquipmentType.values.firstWhere(
      (e) => e.toString().split('.').last == json['type'],
    ),
    description: json['description'] as String,
    images: List<String>.from(json['images'] as List),
    pricePerHour: (json['pricePerHour'] as num).toDouble(),
    location: Location.fromJson(json['location'] as Map<String, dynamic>),
    status: EquipmentStatus.values.firstWhere(
      (e) => e.toString().split('.').last == json['status'],
    ),
    averageRating: (json['averageRating'] as num).toDouble(),
    reviewCount: json['reviewCount'] as int,
    supplierId: json['supplierId'] as String,
    createdAt: DateTime.parse(json['createdAt'] as String),
    updatedAt: DateTime.parse(json['updatedAt'] as String),
  );
}

class EquipmentModel extends EquipmentEntity {
  EquipmentModel({
    required String id,
    required String name,
    required String category,
    required EquipmentType type,
    required String description,
    required List<String> images,
    required double pricePerHour,
    required Location location,
    required EquipmentStatus status,
    required double averageRating,
    required int reviewCount,
    required String supplierId,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : super(
    id: id,
    name: name,
    category: category,
    type: type,
    description: description,
    images: images,
    pricePerHour: pricePerHour,
    location: location,
    status: status,
    averageRating: averageRating,
    reviewCount: reviewCount,
    supplierId: supplierId,
    createdAt: createdAt,
    updatedAt: updatedAt,
  );

  String getTypeDisplay() {
    return type == EquipmentType.mobile ? '이동형' : '고정형';
  }

  String getStatusDisplay() {
    switch (status) {
      case EquipmentStatus.available:
        return '사용 가능';
      case EquipmentStatus.rented:
        return '렌트 중';
      case EquipmentStatus.maintenance:
        return '점검 중';
    }
  }

  bool isAvailable() => status == EquipmentStatus.available;

  String getRatingDisplay() {
    if (reviewCount == 0) return '평점 없음';
    return '$averageRating ★ ($reviewCount)';
  }

  double getDiscountedPrice(int rentalHours) {
    double basePrice = pricePerHour * rentalHours;
    if (averageRating >= 4.8 && reviewCount >= 50) {
      return basePrice * 0.95;
    } else if (averageRating >= 4.5 && reviewCount >= 30) {
      return basePrice * 0.97;
    }
    return basePrice;
  }

  PriceCategory getPriceCategory() {
    if (pricePerHour < 30000) return PriceCategory.cheap;
    if (pricePerHour < 70000) return PriceCategory.moderate;
    if (pricePerHour < 150000) return PriceCategory.expensive;
    return PriceCategory.premium;
  }

  bool isNewEquipment() {
    return DateTime.now().difference(createdAt).inDays < 30;
  }
}
```

### 4.4 Booking 모델

```dart
// lib/features/booking/data/models/booking_model.dart

enum BookingStatus { pending, confirmed, ongoing, completed, cancelled }

class BookingEntity {
  final String id;
  final String equipmentId;
  final String renterId;
  final String supplierId;
  final DateTime startTime;
  final DateTime endTime;
  final BookingStatus status;
  final double totalAmount;
  final double platformFee;
  final String paymentId;
  final DateTime createdAt;
  final DateTime updatedAt;

  BookingEntity({
    required this.id,
    required this.equipmentId,
    required this.renterId,
    required this.supplierId,
    required this.startTime,
    required this.endTime,
    required this.status,
    required this.totalAmount,
    required this.platformFee,
    required this.paymentId,
    required this.createdAt,
    required this.updatedAt,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'equipmentId': equipmentId,
    'renterId': renterId,
    'supplierId': supplierId,
    'startTime': startTime.toIso8601String(),
    'endTime': endTime.toIso8601String(),
    'status': status.toString().split('.').last,
    'totalAmount': totalAmount,
    'platformFee': platformFee,
    'paymentId': paymentId,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
  };

  factory BookingEntity.fromJson(Map<String, dynamic> json) => BookingEntity(
    id: json['id'] as String,
    equipmentId: json['equipmentId'] as String,
    renterId: json['renterId'] as String,
    supplierId: json['supplierId'] as String,
    startTime: DateTime.parse(json['startTime'] as String),
    endTime: DateTime.parse(json['endTime'] as String),
    status: BookingStatus.values.firstWhere(
      (e) => e.toString().split('.').last == json['status'],
    ),
    totalAmount: (json['totalAmount'] as num).toDouble(),
    platformFee: (json['platformFee'] as num).toDouble(),
    paymentId: json['paymentId'] as String,
    createdAt: DateTime.parse(json['createdAt'] as String),
    updatedAt: DateTime.parse(json['updatedAt'] as String),
  );
}

class BookingModel extends BookingEntity {
  BookingModel({
    required String id,
    required String equipmentId,
    required String renterId,
    required String supplierId,
    required DateTime startTime,
    required DateTime endTime,
    required BookingStatus status,
    required double totalAmount,
    required double platformFee,
    required String paymentId,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : super(
    id: id,
    equipmentId: equipmentId,
    renterId: renterId,
    supplierId: supplierId,
    startTime: startTime,
    endTime: endTime,
    status: status,
    totalAmount: totalAmount,
    platformFee: platformFee,
    paymentId: paymentId,
    createdAt: createdAt,
    updatedAt: updatedAt,
  );

  int getRentalHours() {
    return endTime.difference(startTime).inHours;
  }

  double getSupplierEarnings() {
    return totalAmount - platformFee;
  }

  String getStatusDisplay() {
    switch (status) {
      case BookingStatus.pending:
        return '대기 중';
      case BookingStatus.confirmed:
        return '확정됨';
      case BookingStatus.ongoing:
        return '진행 중';
      case BookingStatus.completed:
        return '완료됨';
      case BookingStatus.cancelled:
        return '취소됨';
    }
  }

  bool canBeCancelled() {
    return status == BookingStatus.pending || status == BookingStatus.confirmed;
  }

  bool isOngoing() {
    final now = DateTime.now();
    return now.isAfter(startTime) && now.isBefore(endTime);
  }

  bool isUpcoming() {
    return DateTime.now().isBefore(startTime);
  }
}
```

### 4.5 Chat 모델 (추가)

```dart
// lib/features/chat/data/models/chat_model.dart

class ChatEntity {
  final String id;
  final String senderId;
  final String receiverId;
  final String lastMessage;
  final DateTime lastMessageTime;
  final int unreadCount;
  final DateTime createdAt;
  final DateTime updatedAt;

  ChatEntity({
    required this.id,
    required this.senderId,
    required this.receiverId,
    required this.lastMessage,
    required this.lastMessageTime,
    required this.unreadCount,
    required this.createdAt,
    required this.updatedAt,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'senderId': senderId,
    'receiverId': receiverId,
    'lastMessage': lastMessage,
    'lastMessageTime': lastMessageTime.toIso8601String(),
    'unreadCount': unreadCount,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
  };

  factory ChatEntity.fromJson(Map<String, dynamic> json) => ChatEntity(
    id: json['id'] as String,
    senderId: json['senderId'] as String,
    receiverId: json['receiverId'] as String,
    lastMessage: json['lastMessage'] as String,
    lastMessageTime: DateTime.parse(json['lastMessageTime'] as String),
    unreadCount: json['unreadCount'] as int,
    createdAt: DateTime.parse(json['createdAt'] as String),
    updatedAt: DateTime.parse(json['updatedAt'] as String),
  );
}

class ChatModel extends ChatEntity {
  ChatModel({
    required String id,
    required String senderId,
    required String receiverId,
    required String lastMessage,
    required DateTime lastMessageTime,
    required int unreadCount,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : super(
    id: id,
    senderId: senderId,
    receiverId: receiverId,
    lastMessage: lastMessage,
    lastMessageTime: lastMessageTime,
    unreadCount: unreadCount,
    createdAt: createdAt,
    updatedAt: updatedAt,
  );

  String getLastMessagePreview({int length = 40}) {
    if (lastMessage.length > length) {
      return '${lastMessage.substring(0, length)}...';
    }
    return lastMessage;
  }

  bool hasUnreadMessages() {
    return unreadCount > 0;
  }

  String getUnreadCountDisplay() {
    if (unreadCount == 0) return '';
    if (unreadCount > 99) return '99+';
    return unreadCount.toString();
  }
}
```

### 4.6 Message 모델 (추가)

```dart
// lib/features/chat/data/models/message_model.dart

class MessageEntity {
  final String id;
  final String chatId;
  final String senderId;
  final String content;
  final String? imageUrl;
  final bool isRead;
  final DateTime createdAt;

  MessageEntity({
    required this.id,
    required this.chatId,
    required this.senderId,
    required this.content,
    required this.imageUrl,
    required this.isRead,
    required this.createdAt,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'chatId': chatId,
    'senderId': senderId,
    'content': content,
    'imageUrl': imageUrl,
    'isRead': isRead,
    'createdAt': createdAt.toIso8601String(),
  };

  factory MessageEntity.fromJson(Map<String, dynamic> json) => MessageEntity(
    id: json['id'] as String,
    chatId: json['chatId'] as String,
    senderId: json['senderId'] as String,
    content: json['content'] as String,
    imageUrl: json['imageUrl'] as String?,
    isRead: json['isRead'] as bool,
    createdAt: DateTime.parse(json['createdAt'] as String),
  );
}

class MessageModel extends MessageEntity {
  MessageModel({
    required String id,
    required String chatId,
    required String senderId,
    required String content,
    String? imageUrl,
    required bool isRead,
    required DateTime createdAt,
  }) : super(
    id: id,
    chatId: chatId,
    senderId: senderId,
    content: content,
    imageUrl: imageUrl,
    isRead: isRead,
    createdAt: createdAt,
  );

  bool isImage() {
    return imageUrl != null && imageUrl!.isNotEmpty;
  }

  String getTimeDisplay() {
    final now = DateTime.now();
    final difference = now.difference(createdAt);

    if (difference.inMinutes < 1) {
      return '방금 전';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}분 전';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}시간 전';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}일 전';
    } else {
      return '${createdAt.month}월 ${createdAt.day}일';
    }
  }

  String getContentPreview({int length = 100}) {
    if (content.length > length) {
      return '${content.substring(0, length)}...';
    }
    return content;
  }
}
```

### 4.7 Review 모델

```dart
// lib/features/review/data/models/review_model.dart

enum ReviewQuality { poor, average, good, excellent }

class ReviewEntity {
  final String id;
  final String bookingId;
  final String equipmentId;
  final String reviewerId;
  final int rating;
  final String comment;
  final DateTime createdAt;
  final DateTime updatedAt;

  ReviewEntity({
    required this.id,
    required this.bookingId,
    required this.equipmentId,
    required this.reviewerId,
    required this.rating,
    required this.comment,
    required this.createdAt,
    required this.updatedAt,
  });

  Map<String, dynamic> toJson() => {
    'id': id,
    'bookingId': bookingId,
    'equipmentId': equipmentId,
    'reviewerId': reviewerId,
    'rating': rating,
    'comment': comment,
    'createdAt': createdAt.toIso8601String(),
    'updatedAt': updatedAt.toIso8601String(),
  };

  factory ReviewEntity.fromJson(Map<String, dynamic> json) => ReviewEntity(
    id: json['id'] as String,
    bookingId: json['bookingId'] as String,
    equipmentId: json['equipmentId'] as String,
    reviewerId: json['reviewerId'] as String,
    rating: json['rating'] as int,
    comment: json['comment'] as String,
    createdAt: DateTime.parse(json['createdAt'] as String),
    updatedAt: DateTime.parse(json['updatedAt'] as String),
  );
}

class ReviewModel extends ReviewEntity {
  ReviewModel({
    required String id,
    required String bookingId,
    required String equipmentId,
    required String reviewerId,
    required int rating,
    required String comment,
    required DateTime createdAt,
    required DateTime updatedAt,
  }) : super(
    id: id,
    bookingId: bookingId,
    equipmentId: equipmentId,
    reviewerId: reviewerId,
    rating: rating,
    comment: comment,
    createdAt: createdAt,
    updatedAt: updatedAt,
  );

  String getRatingStars() {
    return '★' * rating + '☆' * (5 - rating);
  }

  ReviewQuality getQuality() {
    if (rating >= 5) return ReviewQuality.excellent;
    if (rating >= 4) return ReviewQuality.good;
    if (rating >= 3) return ReviewQuality.average;
    return ReviewQuality.poor;
  }

  String getCommentPreview({int length = 50}) {
    if (comment.length > length) {
      return '${comment.substring(0, length)}...';
    }
    return comment;
  }

  bool isRecent() {
    return DateTime.now().difference(createdAt).inDays < 7;
  }
}
```

---

## 5. JSON 직렬화 예제

### 5.1 Equipment JSON 변환

```dart
// Equipment를 JSON으로 변환
final equipment = EquipmentModel(
  id: 'eq-001',
  name: '100마력 트랙터',
  category: '트랙터',
  type: EquipmentType.mobile,
  description: '신형 현대 100마력 트랙터',
  images: ['https://example.com/image1.jpg'],
  pricePerHour: 50000,
  location: Location(
    latitude: 37.4979,
    longitude: 127.0276,
    address: '경기도 성남시',
    city: '경기도',
    country: '대한민국',
  ),
  status: EquipmentStatus.available,
  averageRating: 4.8,
  reviewCount: 15,
  supplierId: 'user-001',
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
);

// JSON으로 변환
Map<String, dynamic> json = equipment.toJson();

// JSON에서 Equipment로 변환
EquipmentModel restoredEquipment = EquipmentModel(
  id: json['id'],
  name: json['name'],
  category: json['category'],
  type: EquipmentType.values.firstWhere(
    (e) => e.toString().split('.').last == json['type'],
  ),
  // ... 나머지 필드
);
```

### 5.2 Chat & Message JSON 변환

```dart
// Chat을 JSON으로 변환
final chat = ChatModel(
  id: 'chat-001',
  senderId: 'user-001',
  receiverId: 'user-002',
  lastMessage: '네, 예약 받겠습니다.',
  lastMessageTime: DateTime.now(),
  unreadCount: 0,
  createdAt: DateTime.now(),
  updatedAt: DateTime.now(),
);

Map<String, dynamic> chatJson = chat.toJson();

// Message를 JSON으로 변환
final message = MessageModel(
  id: 'msg-001',
  chatId: 'chat-001',
  senderId: 'user-001',
  content: '안녕하세요. 트랙터 렌트에 관심이 있으신가요?',
  imageUrl: null,
  isRead: true,
  createdAt: DateTime.now(),
);

Map<String, dynamic> messageJson = message.toJson();
```

---

## 6. LocalStorage 저장 구조

### 6.1 sqflite를 사용한 로컬 데이터베이스

```dart
// lib/core/database/app_database.dart

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';

class AppDatabase {
  static const String _databaseName = 'danngam.db';
  static const int _databaseVersion = 1;

  static final AppDatabase _instance = AppDatabase._internal();

  factory AppDatabase() {
    return _instance;
  }

  AppDatabase._internal();

  Database? _database;

  Future<Database> get database async {
    _database ??= await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, _databaseName);

    return openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _createTables,
    );
  }

  Future<void> _createTables(Database db, int version) async {
    // Users 테이블
    await db.execute('''
      CREATE TABLE users (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        phone TEXT NOT NULL UNIQUE,
        email TEXT NOT NULL UNIQUE,
        profileImage TEXT,
        latitude REAL NOT NULL,
        longitude REAL NOT NULL,
        address TEXT NOT NULL,
        city TEXT NOT NULL,
        country TEXT NOT NULL,
        rating REAL DEFAULT 0.0,
        reviewCount INTEGER DEFAULT 0,
        role TEXT NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      )
    ''');

    // Equipment 테이블
    await db.execute('''
      CREATE TABLE equipment (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        category TEXT NOT NULL,
        type TEXT NOT NULL,
        description TEXT NOT NULL,
        images TEXT NOT NULL,
        pricePerHour REAL NOT NULL,
        latitude REAL NOT NULL,
        longitude REAL NOT NULL,
        address TEXT NOT NULL,
        city TEXT NOT NULL,
        country TEXT NOT NULL,
        status TEXT NOT NULL,
        averageRating REAL DEFAULT 0.0,
        reviewCount INTEGER DEFAULT 0,
        supplierId TEXT NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (supplierId) REFERENCES users(id)
      )
    ''');

    // Bookings 테이블
    await db.execute('''
      CREATE TABLE bookings (
        id TEXT PRIMARY KEY,
        equipmentId TEXT NOT NULL,
        renterId TEXT NOT NULL,
        supplierId TEXT NOT NULL,
        startTime TEXT NOT NULL,
        endTime TEXT NOT NULL,
        status TEXT NOT NULL,
        totalAmount REAL NOT NULL,
        platformFee REAL NOT NULL,
        paymentId TEXT NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (equipmentId) REFERENCES equipment(id),
        FOREIGN KEY (renterId) REFERENCES users(id),
        FOREIGN KEY (supplierId) REFERENCES users(id)
      )
    ''');

    // Chats 테이블
    await db.execute('''
      CREATE TABLE chats (
        id TEXT PRIMARY KEY,
        senderId TEXT NOT NULL,
        receiverId TEXT NOT NULL,
        lastMessage TEXT NOT NULL,
        lastMessageTime TEXT NOT NULL,
        unreadCount INTEGER DEFAULT 0,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (senderId) REFERENCES users(id),
        FOREIGN KEY (receiverId) REFERENCES users(id)
      )
    ''');

    // Messages 테이블
    await db.execute('''
      CREATE TABLE messages (
        id TEXT PRIMARY KEY,
        chatId TEXT NOT NULL,
        senderId TEXT NOT NULL,
        content TEXT NOT NULL,
        imageUrl TEXT,
        isRead INTEGER NOT NULL,
        createdAt TEXT NOT NULL,
        FOREIGN KEY (chatId) REFERENCES chats(id),
        FOREIGN KEY (senderId) REFERENCES users(id)
      )
    ''');

    // Reviews 테이블
    await db.execute('''
      CREATE TABLE reviews (
        id TEXT PRIMARY KEY,
        bookingId TEXT NOT NULL UNIQUE,
        equipmentId TEXT NOT NULL,
        reviewerId TEXT NOT NULL,
        rating INTEGER NOT NULL,
        comment TEXT NOT NULL,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (bookingId) REFERENCES bookings(id),
        FOREIGN KEY (equipmentId) REFERENCES equipment(id),
        FOREIGN KEY (reviewerId) REFERENCES users(id)
      )
    ''');
  }

  Future<void> close() async {
    _database?.close();
  }
}
```

### 6.2 Repository 구현 (Mock 데이터 로드)

```dart
// lib/features/equipment/data/repositories/equipment_repository.dart

import 'package:flutter/services.dart';
import 'dart:convert';
import 'package:sqflite/sqflite.dart';

class EquipmentRepository {
  final Database database;

  EquipmentRepository({required this.database});

  // Mock JSON에서 장비 로드
  Future<List<EquipmentModel>> loadMockEquipments() async {
    try {
      final jsonString = await rootBundle.loadString('assets/data/equipments.json');
      final jsonMap = jsonDecode(jsonString) as Map<String, dynamic>;
      final equipmentsList = jsonMap['equipments'] as List;

      return equipmentsList
          .map((e) => EquipmentModel(
            id: e['id'],
            name: e['name'],
            category: e['category'],
            type: EquipmentType.values.firstWhere(
              (et) => et.toString().split('.').last == e['type'],
            ),
            description: e['description'],
            images: List<String>.from(e['images']),
            pricePerHour: (e['pricePerHour'] as num).toDouble(),
            location: Location.fromJson(e['location']),
            status: EquipmentStatus.values.firstWhere(
              (es) => es.toString().split('.').last == e['status'],
            ),
            averageRating: (e['averageRating'] as num).toDouble(),
            reviewCount: e['reviewCount'],
            supplierId: e['supplierId'],
            createdAt: DateTime.parse(e['createdAt']),
            updatedAt: DateTime.parse(e['updatedAt']),
          ))
          .toList();
    } catch (e) {
      throw Exception('Failed to load equipments: $e');
    }
  }

  // 로컬 DB에 저장
  Future<void> saveEquipments(List<EquipmentModel> equipments) async {
    for (final equipment in equipments) {
      await database.insert(
        'equipment',
        {
          'id': equipment.id,
          'name': equipment.name,
          'category': equipment.category,
          'type': equipment.type.toString().split('.').last,
          'description': equipment.description,
          'images': jsonEncode(equipment.images),
          'pricePerHour': equipment.pricePerHour,
          'latitude': equipment.location.latitude,
          'longitude': equipment.location.longitude,
          'address': equipment.location.address,
          'city': equipment.location.city,
          'country': equipment.location.country,
          'status': equipment.status.toString().split('.').last,
          'averageRating': equipment.averageRating,
          'reviewCount': equipment.reviewCount,
          'supplierId': equipment.supplierId,
          'createdAt': equipment.createdAt.toIso8601String(),
          'updatedAt': equipment.updatedAt.toIso8601String(),
        },
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    }
  }

  // 로컬 DB에서 로드
  Future<List<EquipmentModel>> getEquipments() async {
    final maps = await database.query('equipment');
    return maps.map((map) => EquipmentModel(
      id: map['id'] as String,
      name: map['name'] as String,
      category: map['category'] as String,
      type: EquipmentType.values.firstWhere(
        (e) => e.toString().split('.').last == map['type'],
      ),
      description: map['description'] as String,
      images: List<String>.from(jsonDecode(map['images'] as String)),
      pricePerHour: map['pricePerHour'] as double,
      location: Location(
        latitude: map['latitude'] as double,
        longitude: map['longitude'] as double,
        address: map['address'] as String,
        city: map['city'] as String,
        country: map['country'] as String,
      ),
      status: EquipmentStatus.values.firstWhere(
        (e) => e.toString().split('.').last == map['status'],
      ),
      averageRating: map['averageRating'] as double,
      reviewCount: map['reviewCount'] as int,
      supplierId: map['supplierId'] as String,
      createdAt: DateTime.parse(map['createdAt'] as String),
      updatedAt: DateTime.parse(map['updatedAt'] as String),
    )).toList();
  }
}
```

---

## 7. 백엔드 DB 스키마 (PostgreSQL - 향후)

### 7.1 Users 테이블

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  phone VARCHAR(20) NOT NULL UNIQUE,
  email VARCHAR(255) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  profile_image VARCHAR(500),
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,
  address VARCHAR(500) NOT NULL,
  city VARCHAR(100) NOT NULL,
  country VARCHAR(100) NOT NULL,
  rating DECIMAL(2, 1) DEFAULT 0.0,
  review_count INTEGER DEFAULT 0,
  role VARCHAR(20) NOT NULL CHECK (role IN ('SUPPLIER', 'RENTER')),
  is_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_users_city ON users(city);
```

### 7.2 Equipment 테이블

```sql
CREATE TABLE equipment (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  category VARCHAR(100) NOT NULL,
  type VARCHAR(20) NOT NULL CHECK (type IN ('MOBILE', 'FIXED')),
  description TEXT NOT NULL,
  price_per_hour DECIMAL(10, 2) NOT NULL,
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,
  address VARCHAR(500) NOT NULL,
  city VARCHAR(100) NOT NULL,
  country VARCHAR(100) NOT NULL,
  status VARCHAR(20) DEFAULT 'AVAILABLE' CHECK (status IN ('AVAILABLE', 'RENTED', 'MAINTENANCE')),
  average_rating DECIMAL(2, 1) DEFAULT 0.0,
  review_count INTEGER DEFAULT 0,
  supplier_id UUID NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP,
  FOREIGN KEY (supplier_id) REFERENCES users(id)
);

CREATE INDEX idx_equipment_type ON equipment(type);
CREATE INDEX idx_equipment_category ON equipment(category);
CREATE INDEX idx_equipment_supplier_id ON equipment(supplier_id);
CREATE INDEX idx_equipment_status ON equipment(status);
CREATE INDEX idx_equipment_city ON equipment(city);
CREATE INDEX idx_equipment_location ON equipment(latitude, longitude);
```

### 7.3 Equipment Images 테이블

```sql
CREATE TABLE equipment_images (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  equipment_id UUID NOT NULL,
  image_url VARCHAR(500) NOT NULL,
  display_order INTEGER NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (equipment_id) REFERENCES equipment(id) ON DELETE CASCADE
);

CREATE INDEX idx_equipment_images_equipment_id ON equipment_images(equipment_id);
```

### 7.4 Bookings 테이블

```sql
CREATE TABLE bookings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  equipment_id UUID NOT NULL,
  renter_id UUID NOT NULL,
  supplier_id UUID NOT NULL,
  start_time TIMESTAMP NOT NULL,
  end_time TIMESTAMP NOT NULL,
  status VARCHAR(20) DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'CONFIRMED', 'ONGOING', 'COMPLETED', 'CANCELLED')),
  total_amount DECIMAL(12, 2) NOT NULL,
  platform_fee DECIMAL(12, 2) NOT NULL,
  payment_id UUID,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (equipment_id) REFERENCES equipment(id),
  FOREIGN KEY (renter_id) REFERENCES users(id),
  FOREIGN KEY (supplier_id) REFERENCES users(id)
);

CREATE INDEX idx_bookings_equipment_id ON bookings(equipment_id);
CREATE INDEX idx_bookings_renter_id ON bookings(renter_id);
CREATE INDEX idx_bookings_supplier_id ON bookings(supplier_id);
CREATE INDEX idx_bookings_status ON bookings(status);
CREATE INDEX idx_bookings_start_time ON bookings(start_time);
CREATE INDEX idx_bookings_end_time ON bookings(end_time);
```

### 7.5 Payments 테이블

```sql
CREATE TABLE payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_id UUID NOT NULL UNIQUE,
  amount DECIMAL(12, 2) NOT NULL,
  method VARCHAR(50) NOT NULL CHECK (method IN ('CARD', 'BANK_TRANSFER', 'MOBILE_PAYMENT')),
  status VARCHAR(20) DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'SUCCESS', 'FAILED', 'REFUNDED')),
  transaction_id VARCHAR(255) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (booking_id) REFERENCES bookings(id)
);

CREATE INDEX idx_payments_booking_id ON payments(booking_id);
CREATE INDEX idx_payments_status ON payments(status);
CREATE INDEX idx_payments_transaction_id ON payments(transaction_id);
```

### 7.6 Reviews 테이블

```sql
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  booking_id UUID NOT NULL UNIQUE,
  equipment_id UUID NOT NULL,
  reviewer_id UUID NOT NULL,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  comment TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (booking_id) REFERENCES bookings(id),
  FOREIGN KEY (equipment_id) REFERENCES equipment(id),
  FOREIGN KEY (reviewer_id) REFERENCES users(id)
);

CREATE INDEX idx_reviews_booking_id ON reviews(booking_id);
CREATE INDEX idx_reviews_equipment_id ON reviews(equipment_id);
CREATE INDEX idx_reviews_reviewer_id ON reviews(reviewer_id);
CREATE INDEX idx_reviews_rating ON reviews(rating);
```

### 7.7 Chats 테이블 (추가)

```sql
CREATE TABLE chats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sender_id UUID NOT NULL,
  receiver_id UUID NOT NULL,
  last_message TEXT NOT NULL,
  last_message_time TIMESTAMP NOT NULL,
  unread_count INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (sender_id) REFERENCES users(id),
  FOREIGN KEY (receiver_id) REFERENCES users(id)
);

CREATE INDEX idx_chats_sender_id ON chats(sender_id);
CREATE INDEX idx_chats_receiver_id ON chats(receiver_id);
CREATE INDEX idx_chats_updated_at ON chats(updated_at);
```

### 7.8 Messages 테이블 (추가)

```sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  chat_id UUID NOT NULL,
  sender_id UUID NOT NULL,
  content TEXT NOT NULL,
  image_url VARCHAR(500),
  is_read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (chat_id) REFERENCES chats(id) ON DELETE CASCADE,
  FOREIGN KEY (sender_id) REFERENCES users(id)
);

CREATE INDEX idx_messages_chat_id ON messages(chat_id);
CREATE INDEX idx_messages_sender_id ON messages(sender_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

---

## 8. 관계도 (ER Diagram)

### 텍스트 기반 ER Diagram

```
                           ┌─────────────┐
                           │   Users     │
                           └─────────────┘
                                 │
                    ┌────────────┼────────────┐
                    │            │            │
              (supplier_id)  (renter_id)  (reviewer_id)
                    │            │            │
            ┌───────┴────┐       │       ┌────┴────────┐
            │            │       │       │             │
        ┌───▼───────┐   ┌▼──────▼───┐  ┌▼───────────┐
        │ Equipment │   │  Booking  │  │   Review   │
        └───┬───────┘   └─┬────┬────┘  └────────────┘
            │            │    │
            │     (equipment_id)
            │            │    └────────────┐
            │         (payment_id)         │
            │            │           (equipment_id)
        ┌───▼────────┐  ┌▼─────────┐
        │   Images   │  │ Payment  │
        └────────────┘  └──────────┘

        ┌───────────────────────────────────┐
        │         Chat Messages             │
        ├───────────────────────────────────┤
        │                                   │
        │  Users ───(sender_id)─── Chats   │
        │     └──(receiver_id)────┘   │    │
        │                            │    │
        │                         Messages │
        │                            │    │
        │                        (chat_id)│
        │                                   │
        └───────────────────────────────────┘

관계:
- User (Supplier) --- 1:N --- Equipment
- User (Renter) --- 1:N --- Booking
- Equipment --- 1:N --- Booking
- Equipment --- 1:N --- Review
- Booking --- 1:1 --- Payment
- Booking --- 1:1 --- Review
- User (Reviewer) --- 1:N --- Review
- User --- 1:N --- Chat (양방향)
- Chat --- 1:N --- Message
```

---

## 9. 마이그레이션 전략 (Local → Backend)

### 9.1 마이그레이션 단계

**Phase 1: Mock JSON (현재)**
- 로컬 JSON 파일 기반
- sqflite 캐싱
- UI 개발에 집중

**Phase 2: API 통신 (곧)**
1. HTTP 클라이언트 추가
2. API 엔드포인트 연결
3. 실시간 채팅을 위한 WebSocket 준비

**Phase 3: PostgreSQL (향후)**
1. 백엔드 DB 구축
2. REST API 완성
3. WebSocket 기반 실시간 채팅

### 9.2 API 응답 매핑 예제

```dart
// API 응답 (snake_case)
final apiResponse = {
  'id': 'booking-001',
  'equipment_id': 'eq-001',
  'renter_id': 'user-002',
  'supplier_id': 'user-001',
  'start_time': '2026-02-15T09:00:00.000Z',
  'end_time': '2026-02-15T17:00:00.000Z',
  'status': 'PENDING',
  'total_amount': 400000.0,
  'platform_fee': 32000.0,
  'payment_id': 'pay-001',
  'created_at': '2026-02-14T10:30:00.000Z',
  'updated_at': '2026-02-14T10:30:00.000Z',
};

// Model로 변환 (camelCase)
BookingModel booking = BookingModel(
  id: apiResponse['id'],
  equipmentId: apiResponse['equipment_id'],
  renterId: apiResponse['renter_id'],
  supplierId: apiResponse['supplier_id'],
  startTime: DateTime.parse(apiResponse['start_time']),
  endTime: DateTime.parse(apiResponse['end_time']),
  status: BookingStatus.values.firstWhere(
    (e) => e.toString().split('.').last == apiResponse['status'],
  ),
  totalAmount: (apiResponse['total_amount'] as num).toDouble(),
  platformFee: (apiResponse['platform_fee'] as num).toDouble(),
  paymentId: apiResponse['payment_id'],
  createdAt: DateTime.parse(apiResponse['created_at']),
  updatedAt: DateTime.parse(apiResponse['updated_at']),
);
```

---

## 10. 검증 규칙 (Dart 모델)

### 10.1 Equipment 검증

```dart
class EquipmentValidator {
  static const minPricePerHour = 10000.0;
  static const maxPricePerHour = 1000000.0;
  static const minNameLength = 2;
  static const maxNameLength = 100;

  static List<String> validate(EquipmentModel equipment) {
    List<String> errors = [];

    if (equipment.name.isEmpty ||
        equipment.name.length < minNameLength ||
        equipment.name.length > maxNameLength) {
      errors.add('장비명은 2글자 이상 100글자 이하여야 합니다');
    }

    if (equipment.pricePerHour < minPricePerHour ||
        equipment.pricePerHour > maxPricePerHour) {
      errors.add('가격은 10,000원 이상 1,000,000원 이하여야 합니다');
    }

    if (equipment.images.isEmpty || equipment.images.length > 10) {
      errors.add('이미지는 최소 1개, 최대 10개여야 합니다');
    }

    return errors;
  }
}
```

### 10.2 Booking 검증

```dart
class BookingValidator {
  static List<String> validate(BookingModel booking) {
    List<String> errors = [];

    if (booking.startTime.isAfter(booking.endTime)) {
      errors.add('시작 시간이 종료 시간보다 클 수 없습니다');
    }

    final rentalDuration = booking.endTime.difference(booking.startTime);
    if (rentalDuration.inHours < 1) {
      errors.add('최소 1시간 이상 렌트해야 합니다');
    }

    if (rentalDuration.inDays > 30) {
      errors.add('최대 30일까지 렌트 가능합니다');
    }

    if (booking.startTime.isBefore(DateTime.now())) {
      errors.add('과거 시간으로 예약할 수 없습니다');
    }

    if (booking.totalAmount <= 0) {
      errors.add('총액은 0보다 커야 합니다');
    }

    return errors;
  }
}
```

### 10.3 Review 검증

```dart
class ReviewValidator {
  static const minCommentLength = 10;
  static const maxCommentLength = 500;

  static List<String> validate(ReviewModel review) {
    List<String> errors = [];

    if (review.rating < 1 || review.rating > 5) {
      errors.add('평점은 1~5 사이여야 합니다');
    }

    if (review.comment.length < minCommentLength) {
      errors.add('최소 10글자 이상 작성해주세요');
    }

    if (review.comment.length > maxCommentLength) {
      errors.add('최대 500글자까지만 작성 가능합니다');
    }

    return errors;
  }
}
```

### 10.4 Message 검증

```dart
class MessageValidator {
  static const maxContentLength = 2000;

  static List<String> validate(MessageModel message) {
    List<String> errors = [];

    if (message.content.isEmpty) {
      errors.add('메시지는 비어있을 수 없습니다');
    }

    if (message.content.length > maxContentLength) {
      errors.add('메시지는 최대 2000글자까지만 작성 가능합니다');
    }

    return errors;
  }
}
```

---

## 11. 인수 기준

### 기능 인수 기준

- [x] Equipment 모델에 EquipmentType (MOBILE/FIXED) 포함
- [x] 6개 핵심 모델 정의 (User, Equipment, Booking, Chat, Message, Review)
- [x] 모든 모델에 JSON Serialization 코드 포함
- [x] Location 모델 구현 (거리 계산 기능 포함)
- [x] 모든 enum 타입 정의
- [x] Mock JSON 샘플 데이터 작성
  - users.json (2명의 테스트 사용자)
  - equipments.json (3개의 테스트 장비)
  - bookings.json (2개의 테스트 예약)
  - chats.json (2개의 테스트 채팅)
  - messages.json (4개의 테스트 메시지)

### 기술 인수 기준

- [x] sqflite를 사용한 로컬 데이터베이스 설계
- [x] Repository 패턴 구현 (Mock 데이터 로드 및 저장)
- [x] PostgreSQL 백엔드 DB 스키마 정의
  - 8개 테이블 설계 (users, equipment, bookings, chats, messages, reviews, payments, equipment_images)
  - 적절한 인덱스 및 제약조건 포함
  - 외래키 관계 정의

### 문서 인수 기준

- [x] 아키텍처 개요 (Local vs Backend)
- [x] ER Diagram 포함
- [x] 마이그레이션 전략 정의
- [x] Validation Rules 구현
- [x] 검증 규칙 (Equipment, Booking, Review, Message)

---

## 참고 자료

- [Dart JSON Serialization](https://dart.dev/guides/json)
- [Flutter sqflite](https://pub.dev/packages/sqflite)
- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [REST API Design Best Practices](https://restfulapi.net/)
- [WebSocket for Real-time Chat](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)

---

**마지막 수정**: 2026-02-14
**버전**: 2.0
